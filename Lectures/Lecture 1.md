# Введение в язык C++. Основные типы и операции над ними

## Легенда

1. Общие слова о языке Си

2. Типы переменных. статическая типизация

3. Целочисленные типы

4. Типы с плавающей точкой

5. Строки `std::string` и основные операции над ними

6. `std::vector` и его основные операции

7. Вкратце о `list`, `deque`, `stack`, `queue`, `priority_queue`

8. `std::map` и его основные операции

9. `std::multimap`

10. Потоки `std::istream` и `std::ostream`
___

## Общие слова о языке Си

`C++` произошел от языка `C`. Имеет почти полную обратную совместимость с языком `C`. (`C` - это некое подмножество `C++`).

Стандарт переиздается раз в три года. То есть: `C++23` <- `C++20` <- `C++17` <- `C++14` <- `C++11` <- `C++03`, <- `C++98`,
причём радикальные различия произошли при переходе от `C++03` (Олдскульные плюсы) к `C++11` (Новые плюсы). 

Задержка поддержки стандарта от издания документа до момента реализации в компиляторах составляет 2-3 года.

Создатель - основатель языка `C++`, Бьёрн Страуструп. Комитет по стандартизации - те, кто вводят новые фичи и чинят старые версии `C++`. (**Есть гипотеза, что Создатель написал мир на плюсах**)

## Типы переменных. статическая типизация

`С++` - язык со статической типизацией. При статической типизации все типы известны на момент компиляции. (То есть нельзя в `runtime` подменять типы переменных).
Что-то статическое происходит на этапе компиляции, динамическое - в `runtime`.

## Целочисленные типы (Фундаментальные типы)

- `int` 4 байта
- `long` 4 байта
- `long long` 8 байт
- `short` 2 байта
- `char` 1 байт

Про каждый из этих типов можно сказать `unsigned` и `signed`. Так же можно написать просто `unsiged`, и это будет эквивалентно `unsigned int` (Аналогично с `signed`).

- `size_t` (Обычно эквивалентен `unsigned long long`) достаточен, чтобы индексировать всю оперативную память

**Типы с фиксированной шириной**:

- `int8_t`
- `int16_t`
- `int32_t`
- `int64_t`
- Все вышеупомянутые типы, но `unsiged`: `uint<Число байт>_t` (`uint16_t`)
- `std::byte`
- `bool` (Занимает 1 байт, то есть минимальную ячейку памяти)


## Типы с плавающей точкой (Фундаментальные типы)

- `double` 8 байт
- `float` 4 байта
- `long double` 16 байт

Хранятся в мантиссе и экспоненте. Есть один бит под знак, сколько-то под мантиссу и экспоненту. Экспонента - степень двойки, на которую надо умножить мантиссу, чтобы получить нужное число. Мантисса - биты, кодирующие числовое значение. 

`double` точно может хранить всё, что хранит `int` (Гарантированно). 

## Строки `std::string` и основные операции над ними (Классовые типы)

```cpp
std::string a = "abc";
```

- `operator [](size_t)` Возвращает символ, находящийся по данному индексу. Индексация начинается с нуля.

```cpp
std::cout << a[0]; // 'a'
std::cout << a[3]; // '\0'
std::cout << a[4]; // Undefined Behavior - Выкинет ошибку или какой-то мусор
```

`null-terminated strings` - это строки с завершающим символом с кодом 0 ('\0'). Стандарт гарантирует, что в конце `std::string` будет написан `'\0'` (Для обратной совместимости с языком `C`).

- `.at(size_t)` Идентично `operator [](size_t)`, но с проверкой на выход за границы (Выполняется чуть медленнее из-за проверки)

```cpp
a.at(1) = 'x'; // OK, т.к. семантика идентична с operator [](size_t)
std::cout << a[4]; // Out of range Error
```

- Конкатенация строк (`+`)
- `+=`
- `.push_back(char)`
- `.pop_back()`
- `front()`
- `back()`
- `size()`

И так далее (`insert`, `erase`, ...)

## `std::vector` и его основные операции (Классовые типы)

`std::vector` - это динамический массив (расширяющийся по мере надобности).

```cpp
std::vector<int> v;
```

- `operator [](size_t)`
- `.at(size_t)`
- `push_back(char)`
- `pop_back()`
- `front()`
- `back()`
- `size()`

И так далее (`clear`, `reserve`, `shrink_to_fit`, ...)

## Вкратце о `list`, `deque`, `stack`, `queue`, `priority_queue`

`std::list` - двусвязный список, 

`std::forward_list` - односвязный список (since `C++11`), 

`std::deque` - `double ended queue`, поддерживает `LIFO` и `FIFO`,

`std::stack` - стэк, является надстройкой над деком (`LIFO`),

`std:queue` - очередь, является надстройкой над деком (`FIFO`), 

`std::priority_queue` - пирамида/куча.

## `std::map` и его основные операции

Ассоциативный контейнер, хранящий в себе пары ключ: значение. (То есть Отображение: type T -> type U). Хранит элементы в порядке возрастания. Построен на сбалансированном дереве поиска, а именно - Красно-Черное. Так же не умеет хранить несколько элементов с одинаковым ключом.

Существует еще `std::unordered_map`, который хранит элементы неупорядоченно. Представляет собой хэш-таблицу. (Аналогично для `multimap` `set`, `multiset`).

```cpp
std::map<std::string, int> // std::string - ключ, int - значение
```

- `operator [](Key)` - Возвращает соответствующее значение `Value` ключа, если он находится в `std::map`. Создает пару `<Key, Value>` иначе
- `.at(Key)` - Кидает ошибку при отсутствии соответствующего ключа
- `find(Key)` - Проверка, есть ли такой ключ (Если есть, кинет итератор на этот ключ, иначе - на `end()`, но не суть важно)
- `insert(std::pair<Key, Value>)` - Вставка пары ключ: значение
- `erase(Key)` - Удаляет пару ключ: значение

И так далее...

### `std::multimap`

Аналогичен `std::map`, но умеет хранить несколько элементов с одинаковым ключом. Поэтому нет `operator [](Key)` и `.at(Key)`.

- `.lower_bound(Key)` - Возвращает первый элемент, в котором ключ >= тому ключу, который мы передали
- `.upper_bound(Key)` - Возвращает первый элемент, в котором ключ > тому ключу, который мы передали

И так далее...

## `std::set`

Ассоциативный контейнер, который хранит в себе только значения. Хранятся упорядоченно.

```cpp
std::set<int> s;
```

- `find(Value)`
- `insert(Value)`
- `erase(Value)`

И так далее...

### `std::multiset`

Аналогичен `std::set` (Хранит значения) и `std::multiset` (Может хранить несколько одинаковых значений).

## Потоки `std::istream` и `std::ostream`

- `std::istream` - входной поток консоли

- `std::ostream` - выходной поток консоли

- `std::ifstream` - входной поток файла

- `std::ofstream` - выходной поток файла

- `std::istringstream` - входной поток, работающий со строкой

- `std::ostringstream` - выходной поток, работающий со строкой

Больше инфы про них на 1 лекции нет.